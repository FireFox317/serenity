/*
 * Copyright (c) 2022, Timon Kruiper <timonkruiper@gmail.com>
 *
 * SPDX-License-Identifier: BSD-2-Clause
 */

#include <Kernel/Arch/Interrupts.h>
#include <Kernel/Arch/PageFault.h>
#include <Kernel/Arch/TrapFrame.h>
#include <Kernel/Arch/aarch64/InterruptManagement.h>
#include <Kernel/Interrupts/GenericInterruptHandler.h>
#include <Kernel/Interrupts/SharedIRQHandler.h>
#include <Kernel/Interrupts/UnhandledInterruptHandler.h>
#include <Kernel/KSyms.h>
#include <Kernel/PerformanceManager.h>
#include <Kernel/Thread.h>

namespace Kernel {

static Array<GenericInterruptHandler*, 64> s_interrupt_handlers;

extern "C" void handle_interrupt(TrapFrame&);
extern "C" void handle_interrupt(TrapFrame& trap_frame)
{
    Processor::current().enter_trap(trap_frame, true);

    for (auto& interrupt_controller : InterruptManagement::the().controllers()) {
        auto pending_interrupts = interrupt_controller->pending_interrupts();

        // TODO: Add these interrupts as a source of entropy for randomness.
        u8 irq = 0;
        while (pending_interrupts) {
            if ((pending_interrupts & 0b1) != 0b1) {
                irq += 1;
                pending_interrupts >>= 1;
                continue;
            }

            auto* handler = s_interrupt_handlers[irq];
            VERIFY(handler);
            handler->increment_call_count();
            handler->handle_interrupt(*trap_frame.regs);
            handler->eoi();

            irq += 1;
            pending_interrupts >>= 1;
        }
    }

    Processor::current().exit_trap(trap_frame);
}

static u16 convert_esr_to_exception_code(Kernel::Aarch64::ESR_EL1 esr)
{
    u16 exception_code = 0;
    u8 data_fault_status_code = esr.ISS & 0x3f;
    if (data_fault_status_code >= 0b001100 && data_fault_status_code <= 0b001111) {
        // Permission fault
        exception_code |= 0b1;
    }
    if (data_fault_status_code >= 0b000100 && data_fault_status_code <= 0b000111) {
        // Translation fault
        exception_code &= ~0b1;
    }

    u8 is_write = (esr.ISS & (1 << 6)) == (1 << 6);
    if (is_write)
        exception_code |= 0b10;

    return exception_code;
}

extern "C" void exception_common(Kernel::TrapFrame const* const trap_frame);
extern "C" void exception_common(Kernel::TrapFrame const* const trap_frame)
{
    constexpr bool print_stack_frame = true;
    if constexpr (print_stack_frame) {
        dbgln("Exception Generated by processor!");

        auto* regs = trap_frame->regs;

        dbgln(" x0={:p}  x1={:p}  x2={:p}  x3={:p}  x4={:p}", regs->x[0], regs->x[1], regs->x[2], regs->x[3], regs->x[4]);
        dbgln(" x5={:p}  x6={:p}  x7={:p}  x8={:p}  x9={:p}", regs->x[5], regs->x[6], regs->x[7], regs->x[8], regs->x[9]);
        dbgln("x10={:p} x11={:p} x12={:p} x13={:p} x14={:p}", regs->x[10], regs->x[11], regs->x[12], regs->x[13], regs->x[14]);
        dbgln("x15={:p} x16={:p} x17={:p} x18={:p} x19={:p}", regs->x[15], regs->x[16], regs->x[17], regs->x[18], regs->x[19]);
        dbgln("x20={:p} x21={:p} x22={:p} x23={:p} x24={:p}", regs->x[20], regs->x[21], regs->x[22], regs->x[23], regs->x[24]);
        dbgln("x25={:p} x26={:p} x27={:p} x28={:p} x29={:p}", regs->x[25], regs->x[26], regs->x[27], regs->x[28], regs->x[29]);
        dbgln("x30={:p}", regs->x[30]);

        // Special registers
        dbgln("spsr_el1: {:x}", regs->spsr_el1);
        dbgln("elr_el1: {:x}", regs->elr_el1);
        dbgln("tpidr_el0: {:x}", regs->tpidr_el0);
        dbgln("sp_el0: {:x}", regs->sp_el0);

        auto esr_el1 = Kernel::Aarch64::ESR_EL1::read();
        dbgln("esr_el1: EC({:#b}) IL({:#b}) ISS({:#b}) ISS2({:#b})", esr_el1.EC, esr_el1.IL, esr_el1.ISS, esr_el1.ISS2);
        dbgln("Exception Class: {}", Aarch64::exception_class_to_string(esr_el1.EC));
        if (Aarch64::exception_class_has_set_far(esr_el1.EC))
            dbgln("Faulting Virtual Address: 0x{:x}", Aarch64::FAR_EL1::read().virtual_address);

        if (Aarch64::exception_class_is_data_abort(esr_el1.EC))
            dbgln("Data Fault Status Code: {}", Aarch64::data_fault_status_code_to_string(esr_el1.ISS));

        auto ip = regs->elr_el1;
        auto const* symbol = symbolicate_kernel_address(ip);
        dbgln("\033[31;1m{:p}  {} +{}\033[0m", ip, (symbol ? symbol->name : "(k?)"), (symbol ? ip - symbol->address : 0));

        dump_backtrace_from_base_pointer(regs->x[29]);
    }

    auto esr_el1 = Kernel::Aarch64::ESR_EL1::read();
    if (Aarch64::exception_class_is_data_abort(esr_el1.EC)) {
        auto fault_address = VirtualAddress { Aarch64::FAR_EL1::read().virtual_address };
        auto& regs = *trap_frame->regs;

        auto current_thread = Thread::current();

        if (current_thread) {
            current_thread->set_handling_page_fault(true);
            PerformanceManager::add_page_fault_event(*current_thread, regs);
        }

        ScopeGuard guard = [current_thread] {
            if (current_thread)
                current_thread->set_handling_page_fault(false);
        };

        dbgln("Fault address: {} at: 0x{:x}", fault_address, regs.elr_el1);

        PageFault fault { convert_esr_to_exception_code(esr_el1), fault_address };
        auto response = MM.handle_page_fault(fault);

        if (response == PageFaultResponse::ShouldCrash || response == PageFaultResponse::OutOfMemory || response == PageFaultResponse::BusError) {
            VERIFY_NOT_REACHED();
        } else if (response == PageFaultResponse::Continue) {
            dbgln_if(PAGE_FAULT_DEBUG, "Continuing after resolved page fault");
        } else {
            VERIFY_NOT_REACHED();
        }
        return;
    }

    Kernel::Processor::halt();
}

// FIXME: Share the code below with Arch/x86_64/Interrupts.cpp
//        While refactoring, the interrupt handlers can also be moved into the InterruptManagement class.
GenericInterruptHandler& get_interrupt_handler(u8 interrupt_number)
{
    auto*& handler_slot = s_interrupt_handlers[interrupt_number];
    VERIFY(handler_slot != nullptr);
    return *handler_slot;
}

static void revert_to_unused_handler(u8 interrupt_number)
{
    auto handler = new UnhandledInterruptHandler(interrupt_number);
    handler->register_interrupt_handler();
}

void register_generic_interrupt_handler(u8 interrupt_number, GenericInterruptHandler& handler)
{
    auto*& handler_slot = s_interrupt_handlers[interrupt_number];
    if (handler_slot != nullptr) {
        if (handler_slot->type() == HandlerType::UnhandledInterruptHandler) {
            if (handler_slot) {
                auto* unhandled_handler = static_cast<UnhandledInterruptHandler*>(handler_slot);
                unhandled_handler->unregister_interrupt_handler();
                delete unhandled_handler;
            }
            handler_slot = &handler;
            return;
        }
        if (handler_slot->is_shared_handler() && !handler_slot->is_sharing_with_others()) {
            VERIFY(handler_slot->type() == HandlerType::SharedIRQHandler);
            static_cast<SharedIRQHandler*>(handler_slot)->register_handler(handler);
            return;
        }
        if (!handler_slot->is_shared_handler()) {
            if (handler_slot->type() == HandlerType::SpuriousInterruptHandler) {
                // FIXME: Add support for spurious interrupts on aarch64
                TODO_AARCH64();
            }
            VERIFY(handler_slot->type() == HandlerType::IRQHandler);
            auto& previous_handler = *handler_slot;
            handler_slot = nullptr;
            SharedIRQHandler::initialize(interrupt_number);
            VERIFY(handler_slot);
            static_cast<SharedIRQHandler*>(handler_slot)->register_handler(previous_handler);
            static_cast<SharedIRQHandler*>(handler_slot)->register_handler(handler);
            return;
        }
        VERIFY_NOT_REACHED();
    } else {
        handler_slot = &handler;
    }
}

void unregister_generic_interrupt_handler(u8 interrupt_number, GenericInterruptHandler& handler)
{
    auto*& handler_slot = s_interrupt_handlers[interrupt_number];
    VERIFY(handler_slot != nullptr);
    if (handler_slot->type() == HandlerType::UnhandledInterruptHandler) {
        return;
    }
    if (handler_slot->is_shared_handler() && !handler_slot->is_sharing_with_others()) {
        VERIFY(handler_slot->type() == HandlerType::SharedIRQHandler);
        auto* shared_handler = static_cast<SharedIRQHandler*>(handler_slot);
        shared_handler->unregister_handler(handler);
        if (!shared_handler->sharing_devices_count()) {
            handler_slot = nullptr;
            revert_to_unused_handler(interrupt_number);
        }
        return;
    }
    if (!handler_slot->is_shared_handler()) {
        VERIFY(handler_slot->type() == HandlerType::IRQHandler);
        handler_slot = nullptr;
        revert_to_unused_handler(interrupt_number);
        return;
    }
}

void initialize_interrupts()
{
    for (u8 i = 0; i < s_interrupt_handlers.size(); ++i) {
        auto* handler = new UnhandledInterruptHandler(i);
        handler->register_interrupt_handler();
    }
}

}

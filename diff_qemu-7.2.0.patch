Only in qemu-7.2.0: .vscode
diff --color -rub qemu-7.2.0-orig/accel/hvf/hvf-accel-ops.c qemu-7.2.0/accel/hvf/hvf-accel-ops.c
--- qemu-7.2.0-orig/accel/hvf/hvf-accel-ops.c	2022-12-14 17:28:45
+++ qemu-7.2.0/accel/hvf/hvf-accel-ops.c	2023-04-18 23:04:11
@@ -108,9 +108,11 @@
         return 0;
     }
     
+
     macslot->present = 1;
     macslot->gpa_start = slot->start;
     macslot->size = slot->size;
+    fprintf(stderr, "set_phys_mem (guest physical): %llx %llx (virt in this process %llx) flags %llx\n", slot->start, slot->size, (uint64_t)slot->mem, flags);
     ret = hv_vm_map(slot->mem, slot->start, slot->size, flags);
     assert_hvf_ok(ret);
     return 0;
@@ -242,10 +244,18 @@
 {
     hvf_slot *slot;
 
+
+    if (section == NULL)
+        return;
+
     slot = hvf_find_overlap_slot(
             section->offset_within_address_space,
             int128_get64(section->size));
 
+    if (slot == NULL)
+        return;
+    // fprintf(stderr, "set_dirty_tracking\n");
+
     /* protect region against writes; begin tracking it */
     if (on) {
         slot->flags |= HVF_SLOT_LOG;
@@ -322,6 +332,8 @@
     int x;
     hv_return_t ret;
     HVFState *s;
+
+    printf("calling hvf_accel_init\n");
 
     ret = hv_vm_create(HV_VM_DEFAULT);
     assert_hvf_ok(ret);
diff --color -rub qemu-7.2.0-orig/accel/hvf/hvf-all.c qemu-7.2.0/accel/hvf/hvf-all.c
--- qemu-7.2.0-orig/accel/hvf/hvf-all.c	2022-12-14 17:28:45
+++ qemu-7.2.0/accel/hvf/hvf-all.c	2023-04-13 23:22:58
@@ -38,7 +38,11 @@
     case HV_UNSUPPORTED:
         error_report("Error: HV_UNSUPPORTED");
         break;
+    case HV_ILLEGAL_GUEST_STATE:
+        error_report("Error: HV_ILLEGAL_GUEST_STATE");
+        break;
     default:
+        fprintf(stderr, "ret: %d", ret);
         error_report("Unknown Error");
     }
 
diff --color -rub qemu-7.2.0-orig/hw/arm/bcm2836.c qemu-7.2.0/hw/arm/bcm2836.c
--- qemu-7.2.0-orig/hw/arm/bcm2836.c	2022-12-14 17:28:45
+++ qemu-7.2.0/hw/arm/bcm2836.c	2023-04-14 00:02:03
@@ -133,12 +133,15 @@
         /* TODO: this should be converted to a property of ARM_CPU */
         s->cpu[n].core.mp_affinity = (bc->clusterid << 8) | n;
 
+        fprintf(stderr, "before");
         /* set periphbase/CBAR value for CPU-local registers */
-        if (!object_property_set_int(OBJECT(&s->cpu[n].core), "reset-cbar",
-                                     bc->peri_base, errp)) {
-            return;
+        if (object_property_find(OBJECT(&s->cpu[n].core), "reset-cbar")) {
+            object_property_set_int(OBJECT(&s->cpu[n].core), "reset-cbar",
+                                     bc->peri_base, errp);
         }
+        fprintf(stderr, "after");
 
+
         /* start powered off if not enabled */
         if (!object_property_set_bool(OBJECT(&s->cpu[n].core),
                                       "start-powered-off",
@@ -147,6 +150,9 @@
             return;
         }
 
+        fprintf(stderr, "actually setting has_el3 to false\n");
+        object_property_set_bool(OBJECT(&s->cpu[n]), "has_el3", false, NULL);
+
         if (!qdev_realize(DEVICE(&s->cpu[n].core), NULL, errp)) {
             return;
         }
@@ -166,6 +172,7 @@
                 qdev_get_gpio_in_named(DEVICE(&s->control), "cnthpirq", n));
         qdev_connect_gpio_out(DEVICE(&s->cpu[n].core), GTIMER_SEC,
                 qdev_get_gpio_in_named(DEVICE(&s->control), "cntpsirq", n));
+        
     }
 }
 
@@ -207,7 +214,7 @@
     DeviceClass *dc = DEVICE_CLASS(oc);
     BCM283XClass *bc = BCM283X_CLASS(oc);
 
-    bc->cpu_type = ARM_CPU_TYPE_NAME("cortex-a53");
+    bc->cpu_type = ARM_CPU_TYPE_NAME("host");
     bc->core_count = BCM283X_NCPUS;
     bc->peri_base = 0x3f000000;
     bc->ctrl_base = 0x40000000;
diff --color -rub qemu-7.2.0-orig/hw/arm/boot.c qemu-7.2.0/hw/arm/boot.c
--- qemu-7.2.0-orig/hw/arm/boot.c	2022-12-14 17:28:45
+++ qemu-7.2.0/hw/arm/boot.c	2023-04-18 22:32:03
@@ -1001,6 +1001,7 @@
     /* Assume that raw images are linux kernels, and ELF images are not.  */
     kernel_size = arm_load_elf(info, &elf_entry, &image_low_addr,
                                &image_high_addr, elf_machine, as);
+    fprintf(stderr, "kernel_size: %d\n", kernel_size);
     if (kernel_size > 0 && have_dtb(info)) {
         /*
          * If there is still some room left at the base of RAM, try and put
diff --color -rub qemu-7.2.0-orig/hw/arm/raspi.c qemu-7.2.0/hw/arm/raspi.c
--- qemu-7.2.0-orig/hw/arm/raspi.c	2022-12-14 17:28:45
+++ qemu-7.2.0/hw/arm/raspi.c	2023-04-14 00:34:07
@@ -233,6 +233,7 @@
     /* If the user specified a "firmware" image (e.g. UEFI), we bypass
      * the normal Linux boot process
      */
+    fprintf(stderr, "are we here?\n");
     if (machine->firmware) {
         hwaddr firmware_addr = processor_id <= PROCESSOR_ID_BCM2836
                              ? FIRMWARE_ADDR_2 : FIRMWARE_ADDR_3;
diff --color -rub qemu-7.2.0-orig/hw/core/loader.c qemu-7.2.0/hw/core/loader.c
--- qemu-7.2.0-orig/hw/core/loader.c	2022-12-14 17:28:45
+++ qemu-7.2.0/hw/core/loader.c	2023-04-14 00:33:19
@@ -124,6 +124,7 @@
 ssize_t load_image_targphys_as(const char *filename,
                                hwaddr addr, uint64_t max_sz, AddressSpace *as)
 {
+    fprintf(stderr, "loading %s\n", filename);
     ssize_t size;
 
     size = get_image_size(filename);
Only in qemu-7.2.0/hw/display: hvf crash
Only in qemu-7.2.0/scripts/qapi: __pycache__
Only in qemu-7.2.0/scripts/tracetool: __pycache__
Only in qemu-7.2.0/scripts/tracetool/backend: __pycache__
Only in qemu-7.2.0/scripts/tracetool/format: __pycache__
diff --color -rub qemu-7.2.0-orig/target/arm/cpu.c qemu-7.2.0/target/arm/cpu.c
--- qemu-7.2.0-orig/target/arm/cpu.c	2022-12-14 17:28:45
+++ qemu-7.2.0/target/arm/cpu.c	2023-04-13 23:33:33
@@ -1350,6 +1350,7 @@
 
 #ifndef CONFIG_USER_ONLY
     if (arm_feature(&cpu->env, ARM_FEATURE_EL3)) {
+        fprintf(stderr, "whoops actually true\n");
         /* Add the has_el3 state CPU property only if EL3 is allowed.  This will
          * prevent "has_el3" from existing on CPUs which cannot support EL3.
          */
diff --color -rub qemu-7.2.0-orig/target/arm/cpu64.c qemu-7.2.0/target/arm/cpu64.c
--- qemu-7.2.0-orig/target/arm/cpu64.c	2022-12-14 17:28:45
+++ qemu-7.2.0/target/arm/cpu64.c	2023-04-13 23:49:22
@@ -739,6 +739,8 @@
 {
     ARMCPU *cpu = ARM_CPU(obj);
 
+    fprintf(stderr, "calling aarch64_a53_initfn\n");
+
     cpu->dtb_compatible = "arm,cortex-a53";
     set_feature(&cpu->env, ARM_FEATURE_V8);
     set_feature(&cpu->env, ARM_FEATURE_NEON);
diff --color -rub qemu-7.2.0-orig/target/arm/hvf/hvf.c qemu-7.2.0/target/arm/hvf/hvf.c
--- qemu-7.2.0-orig/target/arm/hvf/hvf.c	2022-12-14 17:28:45
+++ qemu-7.2.0/target/arm/hvf/hvf.c	2023-04-18 22:51:23
@@ -489,6 +489,8 @@
     hv_vcpu_exit_t *exit;
     int i;
 
+    fprintf(stderr, "actually calling hvf_arm_get_host_cpu_features\n");
+
     ahcf->dtb_compatible = "arm,arm-v8";
     ahcf->features = (1ULL << ARM_FEATURE_V8) |
                      (1ULL << ARM_FEATURE_NEON) |
@@ -532,6 +534,7 @@
 
 void hvf_arm_set_cpu_features_from_host(ARMCPU *cpu)
 {
+    fprintf(stderr, "calling hvf_arm_set_cpu_features_from_host\n");
     if (!arm_host_cpu_features.dtb_compatible) {
         if (!hvf_enabled() ||
             !hvf_arm_get_host_cpu_features(&arm_host_cpu_features)) {
@@ -1181,6 +1184,12 @@
     flush_cpu_state(cpu);
 
     qemu_mutex_unlock_iothread();
+    fprintf(stderr, "lets go!\n");
+    uint64_t pc;
+
+        r = hv_vcpu_get_reg(cpu->hvf->fd, HV_REG_PC, &pc);
+        assert_hvf_ok(r);
+        printf("pc=0x%llx\n", pc);
     assert_hvf_ok(hv_vcpu_run(cpu->hvf->fd));
 
     /* handle VMEXIT */
@@ -1217,6 +1226,7 @@
         uint32_t cm = (syndrome >> 8) & 0x1;
         uint64_t val = 0;
 
+        printf("pc=%llx, virt=%llx, phys=%llx\n", env->pc, hvf_exit->exception.virtual_address, hvf_exit->exception.physical_address);
         trace_hvf_data_abort(env->pc, hvf_exit->exception.virtual_address,
                              hvf_exit->exception.physical_address, isv,
                              iswrite, s1ptw, len, srt);
@@ -1296,18 +1306,33 @@
         }
         break;
     default:
+    {
         cpu_synchronize_state(cpu);
         trace_hvf_exit(syndrome, ec, env->pc);
-        error_report("0x%llx: unhandled exception ec=0x%x", env->pc, ec);
+        uint64_t val = 0;
+        uint32_t len = 4;
+        address_space_read(&address_space_memory,
+                    env->pc,
+                    MEMTXATTRS_UNSPECIFIED, &val, len);
+        hv_return_t r;
+        uint64_t esr_el1;
+        r = hv_vcpu_get_sys_reg(cpu->hvf->fd, HV_SYS_REG_ESR_EL1, &esr_el1);
+        assert_hvf_ok(r);
+
+        error_report("0x%llx: unhandled exception ec=0x%x val=0x%llx esr_el2=0x%llx virt=0x%llx pys=0x%llx", env->pc, ec, val, syndrome, hvf_exit->exception.virtual_address, hvf_exit->exception.physical_address);
+        abort();
     }
+    }
 
     if (advance_pc) {
         uint64_t pc;
 
         flush_cpu_state(cpu);
 
+
         r = hv_vcpu_get_reg(cpu->hvf->fd, HV_REG_PC, &pc);
         assert_hvf_ok(r);
+        printf("pc increment: %llx\n", pc);
         pc += 4;
         r = hv_vcpu_set_reg(cpu->hvf->fd, HV_REG_PC, pc);
         assert_hvf_ok(r);
